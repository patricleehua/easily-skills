# How To Created Scripts For Agent Skills 

本文是一份关于在 Agent Skills 中如何工程化地编写 `scripts/`，覆盖：

- scripts 的作用与设计原则  
- Python 环境与虚拟环境（venv）  
- Node.js / npm 脚本工程化规范  
- 外部依赖（ffmpeg、yt-dlp 等）  
- 调用 OpenAI API（请求、等待、获取结果）  
- 重试与轮询（polling）模式  
- 如何在 SKILL.md 中正确描述脚本调用规则  

---

## 1. 为什么 Agent Skills 必须配套 Scripts

在 Agent Skills 的体系中，职责是分离的：

- `SKILL.md`  
  负责提示词与流程编排，告诉模型：
  - 要做什么  
  - 什么时候调用  
  - 输出格式是什么  

- `scripts/`  
  负责执行确定性操作，例如：
  - 下载视频文件  
  - 调用 ffmpeg 截图  
  - 请求 OpenAI API  
  - 写入 Markdown / JSON 文件  
  - 批量处理数据  

Scripts 的价值：

1. 降低 token 消耗  
   脚本代码不需要进入模型上下文。

2. 提升稳定性  
   下载、截图、写文件等必须由程序执行，而不是模型“脑补”。

3. 便于复用  
   scripts 可在多个 Skill 中共享。

---

## 2. 推荐的 Scripts 目录结构

一个标准 Skill 工程应当如下：

```text
<skill_name>/
  SKILL.md
  LICENSE.txt
  scripts/
  	biz_name_num
        README.md
        run.py              # Python 脚本入口
        requirements.txt    # Python 依赖
        (或)
        run.mjs             # Node 脚本入口
        package.json        # Node 依赖
  references/
  assets/
  .env.example
```

必须包含：

- 一个业务文件夹(biz_name_num) 
  - 可以包含多个不同的业务操作

- 一个明确入口脚本（run.py / run.mjs）
- 一个依赖说明文件（requirements.txt / package.json）
- 一个环境变量示例（.env.example）
- 一个 README（说明如何运行）

------

## 3. Scripts 的基本设计规范

每个脚本必须明确三件事：

### 输入 Input

- 文件路径
- URL
- 参数（--input、--out）
- （可扩展性其他，结合具体业务场景）

### 输出 Output

- 生成的 Markdown、JSON、图片目录
- stdout 输出 manifest 信息（推荐）
- （可扩展性其他，结合具体业务场景）

### 失败行为 Failure

- stderr 打印错误信息
- exit code 非 0
- 可选写入 error.json
- （可扩展性其他，结合具体业务场景）

------

## 4. Python Scripts：虚拟环境与依赖管理（统一使用 uv + .venv）

### 4.1 为什么必须使用虚拟环境（.venv）

Python 脚本失败的常见原因：

- 缺少依赖包（ModuleNotFoundError）
- Python 版本不兼容
- 不同机器环境差异（全局 Python/包污染）
- 缺少系统工具（例如 ffmpeg）或 PATH 未配置

因此每个 Skill 的脚本必须自带可复现环境，并统一约定：

- `.venv/`：虚拟环境目录（固定命名）
- `uv`：依赖管理与锁定工具
- `pyproject.toml` + `uv.lock`：依赖与锁文件（不再以 requirements.txt 作为主入口）

---

### 4.2 标准做法：uv + .venv（以“当前目录”为基准）

以下步骤假设你正在本地创建一个 Skill 包，例如：

```text
aliyun-bailian-stt/
  SKILL.md
  LICENSE.txt
  scripts/
  references/
  assets/
```

注意：这些文件应当创建在你当前项目目录中，而不是直接创建在 `.claude` 下。
 当 Skill 验证可用后，再将整个 Skill 文件夹移动到对应工具的 skills 目录。

------

#### 4.2.1 创建 scripts 目录（如果尚未创建）

在 Skill 根目录执行：

```
mkdir scripts
```

------

#### 4.2.2 在 scripts 目录初始化 uv 项目

```
cd scripts

# 安装 uv（若尚未安装）
pip install uv

# 初始化项目（生成 pyproject.toml）
uv init
```

------

#### 4.2.3 创建虚拟环境 .venv（必须步骤）

在 `scripts/` 目录执行：

```
# 创建 .venv 虚拟环境（固定目录名）
uv venv
# 部分Windows 带有py管理工具 也可用py 管理工具创建
py -3.12 -m venv .venv
```

说明：

- 执行后会生成 `scripts/.venv/`
- 这是可复现环境的核心产物之一

------

#### 4.2.4 添加依赖并同步到 .venv

```
# 如果没有环境需要初始化环境
uv init

# 添加依赖（更新 pyproject.toml）
uv add requests python-dotenv tenacity openai

# 同步依赖到 .venv，并生成/更新 uv.lock
uv sync
```

如果后续你新增/更新依赖，继续使用：

```
uv add <package>
uv sync
```

------

### 4.3 推荐运行方式：不依赖激活，直接 uv run（跨平台一致）

在 `scripts/` 目录执行：

```
uv run python run.py --help
```

优点：

- 不需要手动 activate
- 更少遇到 Windows 权限/策略问题
- 运行环境稳定可控

------

### 4.4 Windows 运行要求：（建议显式执行）

假设你当前 Skill 位于某个本地路径（示例仅展示格式，按实际路径替换）：

#### 方式 A：推荐方式（无需激活，直接 uv run）

```
powershell -Command "cd <当前Skill目录>\scripts; uv run python run.py --input .\audio.wav --out ..\"
```

说明：uv 自动识别虚拟环境

#### 方式 B：激活 .venv 后运行（手动激活）

- 出现异常必须使用 PowerShell重试一次

- Windows 上建议使用 PowerShell 显式进入目录再执行，避免路径/激活问题。

```
powershell -Command "cd <当前Skill目录>\scripts; .\.venv\Scripts\activate; python --version"
```

运行脚本：

```
powershell -Command "cd <当前Skill目录>\scripts; .\.venv\Scripts\activate; python run.py --input .\audio.wav --out ..\"
```



### 4.5 交付与部署：把当前目录的 Skill 移动到工具的 skills 目录

你在“当前目录”完成 Skill 编写与脚本验证后，再把整个 Skill 文件夹移动到目标工具的 skills 目录中。需提醒用户交互。

#### 4.5.1 Claude Code（项目级）

把 Skill 放入项目目录：

```
<your_project>/
  .claude/
    skills/
      aliyun-bailian-stt/
        SKILL.md
        scripts/
        references/
        assets/
```

#### 4.5.2 Claude Code（全局）

把 Skill 放入用户全局配置的 skills 目录（具体路径以工具文档为准），逻辑是：

```
<Claude配置目录>/
  skills/
    aliyun-bailian-stt/
      ...
```

#### 4.5.3 其他工具（Codex / Cursor / OpenCode）

原则一致：将 Skill 文件夹复制/移动到该工具识别的 skills 路径下。
 迁移时只需要保证：

- Skill 文件夹名不变
- `SKILL.md` 存在且可被扫描
- `scripts/` 资源层保留
- `.venv` 是否随包携带取决于你的分发策略（推荐在部署环境执行 `uv sync` 重新生成）

------

### 4.6 分发策略建议（是否携带 .venv）

推荐两种策略：

1. 开发机本地携带 `.venv`，提交/分发时不携带
   - `.venv` 加入 `.gitignore`
   - 由使用方执行 `uv venv` + `uv sync` 复现环境
2. 内部固定运行环境、且要求开箱即用
   - 可以携带 `.venv`（不推荐跨机器复用，容易因路径/平台差异失效）

通常最佳实践是策略 1。

### 4.3 脚本必须做环境自检（强制推荐）

推荐使用`python -c` 操作自检

示例:

```bash
uv run python -c "import os,sys,shutil;assert sys.version_info>=(3,12),'Python 3.12+ required';assert shutil.which('ffmpeg'),'ffmpeg not found';print('✓ 环境检查通过')"
```

脚本开头应检查：

- Python 版本
- API Key 是否存在(根据实际业务进行)
- ffmpeg 是否安装(根据实际业务进行)

示例：

```python
import os, sys, shutil

def require_env(name: str):
    v = os.getenv(name)
    if not v:
        raise SystemExit(f"缺少环境变量: {name}")
    return v

def require_cmd(cmd: str):
    if shutil.which(cmd) is None:
        raise SystemExit(f"缺少外部依赖: {cmd}")

if sys.version_info < (3, 9):
    raise SystemExit("需要 Python 3.9+")

require_env("OPENAI_API_KEY")
require_cmd("ffmpeg")
```

------

## 5. Node.js Scripts：npm 工程化规范

### 5.1 标准 Node 脚本结构

#### package.json 示例

```json
{
  "name": "skill-scripts",
  "private": true,
  "type": "module",
  "scripts": {
    "run": "node run.mjs"
  },
  "dependencies": {
    "dotenv": "^16.4.5",
    "undici": "^6.19.8"
  },
  "packageManager": "pnpm@9.15.1"  // 可选：锁定包管理器版本
}
```

### 5.2 使用 pnpm 管理依赖

#### 初始化与安装

```bash
# 全局安装 pnpm
npm install -g pnpm

# 进入项目目录
cd scripts

# 安装依赖（自动创建 pnpm-lock.yaml）
pnpm install

# 或安装生产依赖
pnpm install --prod

# 运行脚本
pnpm run run -- --input "<path>"
```

#### 常用 pnpm 命令

```bash
# 添加依赖
pnpm add dotenv            # 生产依赖
pnpm add -D typescript    # 开发依赖
pnpm add -g pnpm          # 全局安装

# 更新依赖
pnpm update
pnpm update dotenv@latest

# 删除依赖
pnpm remove dotenv

# 查看依赖树
pnpm list
pnpm list --depth=1
```

### 5.3 必须锁定依赖版本

务必提交 lock 文件：

- `pnpm-lock.yaml`推荐）
- package-lock.json
- yarn.lock

否则不同机器安装会出现版本漂移。

------

## 6. secrets 管理：.env 与 .env.example

禁止把 key 写死在代码里。

推荐：

- `.env.example` 提供变量说明
- `.env` 本地保存，不提交

------

### .env.example 示例

```env
# description: what is this and how to geting?
OPENAI_API_KEY=your_key_here 
OPENAI_MODEL=gpt-5.2 
HTTP_TIMEOUT_SECONDS=60
```

------

## 7. 等待请求：重试与轮询机制

### 7.1 网络错误与限流：指数退避重试

```python
from tenacity import retry, wait_random_exponential, stop_after_attempt

@retry(wait=wait_random_exponential(min=1, max=30),
       stop=stop_after_attempt(6))
def call(prompt):
    return client.responses.create(model="gpt-5.2", input=prompt)

print(call("写一段总结").output_text)
```

------

### 7.2 异步任务轮询（Polling）

适用于：

- 你自己的内部服务
- 返回 job_id 后需要等待完成

```python
import time, requests

def wait_job(job_url, timeout=300):
    start = time.time()

    while time.time() - start < timeout:
        data = requests.get(job_url).json()

        if data["status"] == "done":
            return data

        if data["status"] == "failed":
            raise RuntimeError("任务失败")

        time.sleep(2)

    raise TimeoutError("轮询超时")
```

------

## 8. 在 skill.md 中正确描述脚本调用规则

必须写清楚：

- 何时调用脚本
- 如何运行
- 输出约定
- 失败约定

可直接复制模板：

```markdown
## 后续处理（Scripts）

当输入文件存在时执行：

- Python:
  python scripts/run.py --input "<file>" --out "<dir>"

输出约定：

- 成功时生成 notes.md 与 assets/
- stdout 打印 JSON manifest：
  {"notes":"...","assets":"..."}

失败约定：

- stderr 输出错误信息
- exit code 非 0
```

------

## 9. 完整端到端脚本模式（推荐协议）

一个成熟脚本应当：

1. 参数化输入（--input、--out）
2. 输出可追溯（notes.md、assets/）
3. stdout 返回 manifest JSON
4. 错误可诊断（stderr + exit code）
5. 具体业务参数

Manifest 示例：

```json
{
  "notes": "./notes.md",
  "assets": "./assets/"
}
```

------

## 10. Scripts 最佳实践 Checklist

- 必须包含 README.md
- 必须包含 requirements.txt 或 package.json
- 必须提供 .env.example
- 必须做环境自检（Python 版本、依赖、工具）
- 必须定义稳定输入输出协议
- 网络请求必须加 timeout
- API 调用必须加 retry/backoff
- 永远不要硬编码 secrets
- 外部工具依赖必须显式说明（ffmpeg、yt-dlp）