# How To Created Scripts For Agent Skills 

本文是一份关于在 Agent Skills 中如何工程化地编写 `scripts/`，覆盖：

- scripts 的作用与设计原则  
- Python 环境与虚拟环境（venv）  
- Node.js / npm 脚本工程化规范  
- 外部依赖（ffmpeg、yt-dlp 等）  
- 调用 OpenAI API（请求、等待、获取结果）  
- 重试与轮询（polling）模式  
- 如何在 skill.md 中正确描述脚本调用规则  

---

## 1. 为什么 Agent Skills 必须配套 Scripts

在 Agent Skills 的体系中，职责是分离的：

- `skill.md`  
  负责提示词与流程编排，告诉模型：
  - 要做什么  
  - 什么时候调用  
  - 输出格式是什么  

- `scripts/`  
  负责执行确定性操作，例如：
  - 下载视频文件  
  - 调用 ffmpeg 截图  
  - 请求 OpenAI API  
  - 写入 Markdown / JSON 文件  
  - 批量处理数据  

Scripts 的价值：

1. 降低 token 消耗  
   脚本代码不需要进入模型上下文。

2. 提升稳定性  
   下载、截图、写文件等必须由程序执行，而不是模型“脑补”。

3. 便于复用  
   scripts 可在多个 Skill 中共享。

---

## 2. 推荐的 Scripts 目录结构

一个标准 Skill 工程应当如下：

```text
<skill_name>/
  skill.md
  scripts/
  	biz_name_num
        README.md
        run.py              # Python 脚本入口
        requirements.txt    # Python 依赖
        (或)
        run.mjs             # Node 脚本入口
        package.json        # Node 依赖
  references/
  assets/
  .env.example
```

必须包含：

- 一个业务文件夹(biz_name_num) 
  - 可以包含多个不同的业务操作

- 一个明确入口脚本（run.py / run.mjs）
- 一个依赖说明文件（requirements.txt / package.json）
- 一个环境变量示例（.env.example）
- 一个 README（说明如何运行）

------

## 3. Scripts 的基本设计规范

每个脚本必须明确三件事：

### 输入 Input

- 文件路径
- URL
- 参数（--input、--out）
- （可扩展性其他，结合具体业务场景）

### 输出 Output

- 生成的 Markdown、JSON、图片目录
- stdout 输出 manifest 信息（推荐）
- （可扩展性其他，结合具体业务场景）

### 失败行为 Failure

- stderr 打印错误信息
- exit code 非 0
- 可选写入 error.json
- （可扩展性其他，结合具体业务场景）

------

## 4. Python Scripts：虚拟环境与依赖管理

### 4.1 为什么必须使用 venv

Python 脚本失败的最常见原因：

- 缺少依赖包（ModuleNotFoundError）
- Python 版本不兼容
- 不同机器环境差异
- 缺少 ffmpeg 等系统工具

因此每个 Skill scripts 都应当自带可复现环境：

- `.venv`
- `requirements.txt`

------

### 4.2 标准做法：venv + requirements.txt

#### requirements.txt 示例

```txt
requests>=2.31.0
python-dotenv>=1.0.0
tenacity>=8.2.0
openai>=2.0.0
```

------

#### 安装步骤

```bash
cd .claude/skills/<skill_name>/scripts

# 创建虚拟环境
python -m venv .venv

# 激活虚拟环境
# macOS/Linux:
source .venv/bin/activate

# Windows PowerShell:
.\.venv\Scripts\Activate.ps1

# 安装依赖
pip install -r requirements.txt
```

------

### 进阶做法:  venv + uv 管理项目



```bash
# -- 激活虚拟环境 --
#linux
source .venv/bin/activate

# windows
.\.venv\Scripts\activate

# -- 初始化环境 --
pip install uv

uv init

uv sync

# -- 安装依赖 --

uv add modelsname

uv lock

```



### 4.3 脚本必须做环境自检（强制推荐）

推荐使用`python -c` 操作自检

示例:

```bash
uv run python -c "import os,sys,shutil;assert sys.version_info>=(3,12),'Python 3.12+ required';assert shutil.which('ffmpeg'),'ffmpeg not found';print('✓ 环境检查通过')"
```

脚本开头应检查：

- Python 版本
- API Key 是否存在(根据实际业务进行)
- ffmpeg 是否安装(根据实际业务进行)

示例：

```python
import os, sys, shutil

def require_env(name: str):
    v = os.getenv(name)
    if not v:
        raise SystemExit(f"缺少环境变量: {name}")
    return v

def require_cmd(cmd: str):
    if shutil.which(cmd) is None:
        raise SystemExit(f"缺少外部依赖: {cmd}")

if sys.version_info < (3, 9):
    raise SystemExit("需要 Python 3.9+")

require_env("OPENAI_API_KEY")
require_cmd("ffmpeg")
```

------

## 5. Node.js Scripts：npm 工程化规范

### 5.1 标准 Node 脚本结构

#### package.json 示例

```json
{
  "name": "skill-scripts",
  "private": true,
  "type": "module",
  "scripts": {
    "run": "node run.mjs"
  },
  "dependencies": {
    "dotenv": "^16.4.5",
    "undici": "^6.19.8"
  },
  "packageManager": "pnpm@9.15.1"  // 可选：锁定包管理器版本
}
```

### 5.2 使用 pnpm 管理依赖

#### 初始化与安装

```bash
# 全局安装 pnpm
npm install -g pnpm

# 进入项目目录
cd scripts

# 安装依赖（自动创建 pnpm-lock.yaml）
pnpm install

# 或安装生产依赖
pnpm install --prod

# 运行脚本
pnpm run run -- --input "<path>"
```

#### 常用 pnpm 命令

```bash
# 添加依赖
pnpm add dotenv            # 生产依赖
pnpm add -D typescript    # 开发依赖
pnpm add -g pnpm          # 全局安装

# 更新依赖
pnpm update
pnpm update dotenv@latest

# 删除依赖
pnpm remove dotenv

# 查看依赖树
pnpm list
pnpm list --depth=1
```

### 5.3 必须锁定依赖版本

务必提交 lock 文件：

- `pnpm-lock.yaml`推荐）
- package-lock.json
- yarn.lock

否则不同机器安装会出现版本漂移。

------

## 6. secrets 管理：.env 与 .env.example

禁止把 key 写死在代码里。

推荐：

- `.env.example` 提供变量说明
- `.env` 本地保存，不提交

------

### .env.example 示例

```env
# description: what is this and how to geting?
OPENAI_API_KEY=your_key_here 
OPENAI_MODEL=gpt-5.2 
HTTP_TIMEOUT_SECONDS=60
```

------

## 7. 等待请求：重试与轮询机制

### 7.1 网络错误与限流：指数退避重试

```python
from tenacity import retry, wait_random_exponential, stop_after_attempt

@retry(wait=wait_random_exponential(min=1, max=30),
       stop=stop_after_attempt(6))
def call(prompt):
    return client.responses.create(model="gpt-5.2", input=prompt)

print(call("写一段总结").output_text)
```

------

### 7.2 异步任务轮询（Polling）

适用于：

- 你自己的内部服务
- 返回 job_id 后需要等待完成

```python
import time, requests

def wait_job(job_url, timeout=300):
    start = time.time()

    while time.time() - start < timeout:
        data = requests.get(job_url).json()

        if data["status"] == "done":
            return data

        if data["status"] == "failed":
            raise RuntimeError("任务失败")

        time.sleep(2)

    raise TimeoutError("轮询超时")
```

------

## 8. 在 skill.md 中正确描述脚本调用规则

必须写清楚：

- 何时调用脚本
- 如何运行
- 输出约定
- 失败约定

可直接复制模板：

```markdown
## 后续处理（Scripts）

当输入文件存在时执行：

- Python:
  python scripts/run.py --input "<file>" --out "<dir>"

输出约定：

- 成功时生成 notes.md 与 assets/
- stdout 打印 JSON manifest：
  {"notes":"...","assets":"..."}

失败约定：

- stderr 输出错误信息
- exit code 非 0
```

------

## 9. 完整端到端脚本模式（推荐协议）

一个成熟脚本应当：

1. 参数化输入（--input、--out）
2. 输出可追溯（notes.md、assets/）
3. stdout 返回 manifest JSON
4. 错误可诊断（stderr + exit code）
5. 具体业务参数

Manifest 示例：

```json
{
  "notes": "./notes.md",
  "assets": "./assets/"
}
```

------

## 10. Scripts 最佳实践 Checklist

- 必须包含 README.md
- 必须包含 requirements.txt 或 package.json
- 必须提供 .env.example
- 必须做环境自检（Python 版本、依赖、工具）
- 必须定义稳定输入输出协议
- 网络请求必须加 timeout
- API 调用必须加 retry/backoff
- 永远不要硬编码 secrets
- 外部工具依赖必须显式说明（ffmpeg、yt-dlp）